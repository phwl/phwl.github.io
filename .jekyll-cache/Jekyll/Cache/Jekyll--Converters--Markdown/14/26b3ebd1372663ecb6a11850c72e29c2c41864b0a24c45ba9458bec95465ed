I"QX<p>This post details how to use the GPIO peripheral on the ARM linux image 
built in <a href="/2021/emulated-ARM-Linux-with-Buildroot-and-QEMU/">Creating an emulated ARM Linux system using Buildroot and QEMU</a></p>

<h2 id="1-linux-libgpiod-library-command-line-tools">1. Linux libgpiod Library Command Line Tools</h2>
<p>Since Linux v4.8, the standard way of using Linux GPIO has been via 
<a href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/">libgpiod</a>.
Prior to the introduction of libgpiod, the
sysfs interface was used, but sysfs is depreciated and was removed from the mainline Linux kernel
in 2020. 
The best source of information on libgpiod
<a href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/about/">comes with the library</a>.</p>

<p>Here is a summary of the command line tools that it comes with:</p>
<ul>
  <li>
    <p>gpiodetect - list all gpiochips present on the system, their names, labels
            and number of GPIO lines</p>
  </li>
  <li>
    <p>gpioinfo   - list all lines of specified gpiochips, their names, consumers,
            direction, active state and additional flags</p>
  </li>
  <li>
    <p>gpioget    - read values of specified GPIO lines</p>
  </li>
  <li>
    <p>gpioset    - set values of specified GPIO lines, potentially keep the lines
            exported and wait until timeout, user input or signal</p>
  </li>
  <li>
    <p>gpiofind   - find the gpiochip name and line offset given the line name</p>
  </li>
  <li>
    <p>gpiomon    - wait for events on GPIO lines, specify which events to watch,
            how many events to process before exiting or if the events
            should be reported to the console.</p>
  </li>
</ul>

<p>Examples (also from the documentation) of how they are used:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Examples:

    # Read the value of a single GPIO line.
    $ gpioget gpiochip1 23
    0

    # Read two values at the same time. Set the active state of the lines
    # to low.
    $ gpioget --active-low gpiochip1 23 24
    1 1

    # Set values of two lines, then daemonize and wait for a signal (SIGINT or
    # SIGTERM) before releasing them.
    $ gpioset --mode=signal --background gpiochip1 23=1 24=0

    # Set the value of a single line, then exit immediately. This is useful
    # for floating pins.
    $ gpioset gpiochip1 23=1

    # Find a GPIO line by name.
    $ gpiofind "USR-LED-2"
    gpiochip1 23

    # Toggle a GPIO by name, then wait for the user to press ENTER.
    $ gpioset --mode=wait `gpiofind "USR-LED-2"`=1

    # Wait for three rising edge events on a single GPIO line, then exit.
    $ gpiomon --num-events=3 --rising-edge gpiochip2 3
    event:  RISING EDGE offset: 3 timestamp: [    1151.814356387]
    event:  RISING EDGE offset: 3 timestamp: [    1151.815449803]
    event:  RISING EDGE offset: 3 timestamp: [    1152.091556803]

    # Wait for a single falling edge event. Specify a custom output format.
    $ gpiomon --format="%e %o %s %n" --falling-edge gpiochip1 4
    0 4 1156 615459801

    # Pause execution until a single event of any type occurs. Don't print
    # anything. Find the line by name.
    $ gpiomon --num-events=1 --silent `gpiofind "USR-IN"`

    # Monitor multiple lines, exit after the first event.
    $ gpiomon --silent --num-events=1 gpiochip0 2 3 5
</code></pre></div></div>
<p>`</p>

<p>Here we use the <code class="language-plaintext highlighter-rouge">libgpiod</code> tools to determine there is one gpiochip (gpiochip0) and that they are initially all set as inputs. We can also see that while
gpio lines can have names, all of the ones on this machine are unnamed.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phwl@bream:~/src/teaching/buildroot/output/images$ H=~/src/teaching
phwl@bream:~/src/teaching/buildroot/output/images$ cd $H/buildroot/output/imagesphwl@bream:~/src/teaching/buildroot/output/images$ ./start-qemu.sh 
Booting Linux on physical CPU 0x0000000000 [0x410fd034]
...
Welcome to Buildroot
buildroot login: root
# gpiodetect 
gpiochip0 [9030000.pl061] (8 lines)
# gpioinfo
gpiochip0 - 8 lines:
	line   0:      unnamed       unused   input  active-high 
	line   1:      unnamed       unused   input  active-high 
	line   2:      unnamed       unused   input  active-high 
	line   3:      unnamed       unused   input  active-high 
	line   4:      unnamed       unused   input  active-high 
	line   5:      unnamed       unused   input  active-high 
	line   6:      unnamed       unused   input  active-high 
	line   7:      unnamed       unused   input  active-high 
# 
</code></pre></div></div>

<p>Here is a link to a tutorial explaining the
changes
<a href="https://microhobby.com.br/blog/2020/02/02/new-linux-kernel-5-5-new-interfaces-in-gpiolib/">https://microhobby.com.br/blog/2020/02/02/new-linux-kernel-5-5-new-interfaces-in-gpiolib/</a>.</p>

<h2 id="step-2-libgpiod-application-programmers-interface-programming">Step 2 libgpiod Application Programmersâ€™ Interface Programming</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
</pre></td><td class="code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;assert.h&gt;
#include &lt;gpiod.h&gt;
#include &lt;time.h&gt;
</span> 
<span class="cp">#define	CONSUMER "gpiod-lab"		</span><span class="cm">/* this identifies the consumer */</span><span class="cp">
#define NUM_THREADS 2				</span><span class="cm">/* we have one writer and one reader */</span><span class="cp">
#define	NSPERIOD	200000000ULL	</span><span class="cm">/* output period in ns */</span><span class="cp">
</span>
<span class="n">pthread_mutex_t</span> <span class="n">mlock</span><span class="p">;</span>			<span class="cm">/* only reader or writer can access line */</span>
 
<span class="cm">/* create thread argument struct for thr_func() */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_thread_data_t</span> 
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpiod_line</span> <span class="o">*</span><span class="n">gpioline</span><span class="p">;</span>
<span class="p">}</span> <span class="n">thread_data_t</span><span class="p">;</span>
 
<span class="cm">/* high resolution time stamp */</span>
<span class="kt">double</span>
<span class="nf">gethrtime</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">r</span><span class="p">;</span>
	<span class="kt">int64_t</span>	<span class="n">ts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">t</span><span class="p">;</span>

	<span class="cm">/* read the time stamp */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
	<span class="n">ts</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="n">t</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="mi">1000000000</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="n">t</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ts</span> <span class="o">/</span> <span class="mf">1.0e9</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
**	Display edges 
*/</span>
<span class="kt">void</span>
<span class="nf">gpio_reader</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpiod_line</span> <span class="o">*</span><span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">timeout</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NSPERIOD</span> <span class="o">/</span> <span class="mi">100ULL</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">shortdelay</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NSPERIOD</span> <span class="o">/</span> <span class="mi">100ULL</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">rem</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">event</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span>
	<span class="p">{</span>
		<span class="cm">/* get lock */</span>
		<span class="n">pthread_mutex_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mlock</span><span class="p">);</span>

		<span class="cm">/* get line */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">gpiod_line_request_both_edges_events</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">CONSUMER</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>

		<span class="cm">/* wait for an event */</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">gpiod_line_event_wait</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* success */</span>
		<span class="p">{</span>
			<span class="cm">/* read the gpio pin value */</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">gpiod_line_get_value</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"Event %d: Pin=%d at t=%fs</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">++</span><span class="n">event</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">gethrtime</span><span class="p">());</span>
		<span class="p">}</span>

		<span class="cm">/* release the line */</span>
	<span class="nl">release:</span>
		<span class="n">gpiod_line_release</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
		<span class="n">pthread_mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mlock</span><span class="p">);</span>
		<span class="n">nanosleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shortdelay</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
**	Blink a number of times
*/</span>
<span class="kt">void</span>
<span class="nf">gpio_writer</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpiod_line</span> <span class="o">*</span><span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">line_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">delay</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NSPERIOD</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">rem</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">r</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* config as output and set a description */</span>
		<span class="n">pthread_mutex_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mlock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">gpiod_line_request_output</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">CONSUMER</span><span class="p">,</span> <span class="n">line_value</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">release</span><span class="p">;</span>

		<span class="cm">/* toggle output */</span>
		<span class="n">line_value</span> <span class="o">=</span> <span class="o">!</span><span class="n">line_value</span><span class="p">;</span>
		<span class="n">gpiod_line_set_value</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">line_value</span><span class="p">);</span>

		<span class="cm">/* release line */</span>
	<span class="nl">release:</span>
		<span class="n">gpiod_line_release</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
		<span class="n">pthread_mutex_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mlock</span><span class="p">);</span>
		<span class="n">nanosleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delay</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* the thread created will either be a reader or writer */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">thr_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">thread_data_t</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">thread_data_t</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
 
	<span class="k">switch</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="cm">/* writer */</span>
			<span class="n">gpio_writer</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">gpioline</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span> <span class="cm">/* reader */</span>
			<span class="n">gpio_reader</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">gpioline</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
 
	<span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="kt">int</span> 
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">pthread_t</span> <span class="n">thr</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">];</span>
	<span class="n">pthread_attr_t</span> <span class="n">attr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
	<span class="cm">/* create a thread_data_t argument array */</span>
	<span class="n">thread_data_t</span> <span class="n">thr_data</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">];</span>

	<span class="cm">/* gpio structures */</span>
	<span class="k">struct</span> <span class="n">gpiod_chip</span> <span class="o">*</span><span class="n">output_chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpiod_line</span> <span class="o">*</span><span class="n">output_line</span><span class="p">;</span>

	<span class="cm">/* open /dev/gpiochip0 */</span>
	<span class="n">output_chip</span> <span class="o">=</span> <span class="n">gpiod_chip_open_by_number</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	
	<span class="cm">/* work on pin 3 */</span>
	<span class="n">output_line</span> <span class="o">=</span> <span class="n">gpiod_chip_get_line</span><span class="p">(</span><span class="n">output_chip</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

	<span class="cm">/* config as output and set a description */</span>
	<span class="n">gpiod_line_request_output</span><span class="p">(</span><span class="n">output_line</span><span class="p">,</span> <span class="n">CONSUMER</span><span class="p">,</span>
				  <span class="n">GPIOD_LINE_ACTIVE_STATE_HIGH</span><span class="p">);</span>

	<span class="cm">/* create threads */</span>
	<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mlock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_THREADS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">thr_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tid</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">thr_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">gpioline</span> <span class="o">=</span> <span class="n">output_line</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thr_func</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thr_data</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span> 
		<span class="p">{</span>
			<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"error: pthread_create, r: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* block until thread 0 completes */</span>
	<span class="n">pthread_join</span><span class="p">(</span><span class="n">thr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
 
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2 id="step-3-driver">Step 3 Driver</h2>
<p>The peripheral used in the
qemu_aarch64_virt machine is described in the 
 <a href="https://developer.arm.com/documentation/ddi0190/b">ARM PrimeCell General Purpose Input/Output (PL061) Technical Reference Manual</a> (which we will call the datasheet) GPIO device. There are
two ways to find out its start address in memory. During boot up, the message</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pl061_gpio 9030000.pl061: PL061 GPIO chip registered
</code></pre></div></div>
<p>or using
<code class="language-plaintext highlighter-rouge">info mtree</code> in the QEMU monitor, you get</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000000009030000-0000000009030fff (prio 0, i/o): pl061
</code></pre></div></div>
<p>Thus the start address (GPIOBASE in the datasheet) is 0x9030000.
The address of GPIODIR is 0x9030400.</p>

:ET